import { parse as parseYAML } from "yaml";
import {
  Project,
  StatementStructures,
  InterfaceDeclarationStructure,
  Structure,
  ClassDeclarationStructure,
  SourceFile,
  Node,
} from "ts-morph";
import fs from "fs-extra";
import path from "path";
import { resolveProject } from "../resolveProject";

interface ExportSourceCommon {
  omit?: string[];
}

interface ExportSource extends ExportSourceCommon {
  path: string;
}

interface ParsedExportSource extends ExportSource {
  source: SourceFile;
}

interface ExportsFileDefinition {
  outputPath: string;
  sources: ExportSource[];
}

interface ExportsYml {
  esm?: boolean;
  exports: ExportsFileDefinition[];
}

interface ReferenceLocator {
  symbolName: string;
  sourceFilePath: string;
}

interface DirectExportableSymbol {
  kind: "directExport";
  name: string;
  sourcePath: string;
  structure: StatementStructures;
  references: ReferenceLocator[];
}

interface EmittedExportableSymbol {
  kind: "emit";
  name: string;
  structure: StatementStructures;
  references: ReferenceLocator[];
}

type ExportableSymbol = DirectExportableSymbol | EmittedExportableSymbol;

const EXPORTS_YML = "exports.yml";

const EXPORTS_FILE_FRONTMATTER = `/**
* GENERATED FILE. DO NOT EDIT DIRECTLY.
*
* This file was generated by the exporter helper.
* To modify this file, use exports.yml and rebuild. Otherwise your changes will be overwritten on the next build.
*/
`;

type Combine<T> = (a: T, b: T) => T;

const combineSet =
  <T>(eq: (x: T, y: T) => boolean = (x, y) => x === y) =>
    (a: T[], b: T[]): T[] => {
      // Really we should provide a Combine<T> for this case
      const aIntersectB = b.filter((x) => a.some((y) => eq(x, y)));
      const aMinusB = a.filter((x) => !aIntersectB.some((y) => eq(x, y)));
      const bMinusA = b.filter((x) => !aIntersectB.some((y) => eq(x, y)));

      return [...aMinusB, ...aIntersectB, ...bMinusA];
    };

const combineUseRight = <T>(_a: T, b: T) => b;

const combineToLiteral =
  <T>(value: T) =>
    (_a: T, _b: T) =>
      value;

const combineObject =
  <T extends {}>(mapping: { [K in keyof T]?: Combine<NonNullable<T[K]>> }) =>
    (a: T, b: T) => {
      const result: Partial<T> = {};

      const combinedKeys = combineSet()(Object.keys(a), Object.keys(b)) as any[];

      for (const key of combinedKeys) {
        // Trust that this is safe
        const aValue = (a as any)[key];
        const bValue = (b as any)[key];

        if (aValue === null || aValue === undefined) {
          result[key as keyof T] = bValue;
        } else if (bValue === null || bValue === undefined) {
          result[key as keyof T] = aValue;
        } else {
          result[key as keyof T] = (mapping[key as keyof T] ?? combineUseRight)(aValue, bValue);
        }
      }

      return result as T;
    };

const combineOnName = <T extends { name: string }>() =>
  combineSet((a: T, b: T) => a.name === b.name);

const combineInterfaces: Combine<InterfaceDeclarationStructure> =
  combineObject<InterfaceDeclarationStructure>({
    name: combineUseRight,
    methods: combineOnName(),
    properties: combineOnName(),
  });

const combineClasses: Combine<ClassDeclarationStructure> = combineObject<ClassDeclarationStructure>(
  {
    name: combineUseRight,
    methods: combineOnName(),
    properties: combineOnName(),
    ctors: combineUseRight,
  }
);

const combineOr =
  <T, U extends T>(check: (x: T) => x is U, c1: Combine<U>, c2?: Combine<T>) =>
    (a: T, b: T): T => {
      if (check(a) && check(b)) {
        return c1(a, b);
      } else if (c2) {
        return c2(a, b);
      } else {
        throw new Error("Could not combine");
      }
    };

const combineStructure: Combine<StatementStructures> = combineOr<
  StatementStructures,
  InterfaceDeclarationStructure
>(
  Structure.isInterface,
  combineInterfaces,
  combineOr<StatementStructures, ClassDeclarationStructure>(Structure.isClass, combineClasses)
);

const combineExportableSymbol: Combine<ExportableSymbol> = combineObject<ExportableSymbol>({
  // Force kind = emit since we are now emitting the output instead of exporting another symbol
  kind: combineToLiteral("emit"),
  structure: combineStructure,
  references: combineSet(
    (a, b) => a.sourceFilePath === b.sourceFilePath && a.symbolName === b.symbolName
  ),
});

async function readExportsYml(): Promise<ExportsYml> {
  return parseYAML(await fs.readFile(path.join(process.cwd(), EXPORTS_YML), "utf-8")) as ExportsYml;
}

async function emitExportsFile(
  project: Project,
  esm: boolean,
  definition: ExportsFileDefinition
): Promise<void> {
  const output = project.createSourceFile(definition.outputPath, undefined, { overwrite: true });

  const sources: ParsedExportSource[] = definition.sources.map((source) => ({
    ...source,
    source: project.getSourceFileOrThrow(source.path),
  }));

  const symbolNameToExport = new Map<string, ExportableSymbol>();

  // 1. Go through all the source files and gather exports
  for (const source of sources) {
    for (const [symbolName, declarations] of source.source.getExportedDeclarations()) {
      if (source.omit && source.omit.includes(symbolName)) {
        console.log(`Omitting exported symbol ${symbolName} from ${source.path}`);
        continue;
      }

      if (declarations.length !== 1) {
        console.warn(
          "Multiple declarations named " +
          symbolName +
          ". Using the first one. This may cause unexpected issues."
        );
      }

      const declaration = declarations[0];

      const structure = (declaration as any).getStructure() as StatementStructures;

      const references: ReferenceLocator[] = Node.isReferenceFindable(declaration)
        ? declaration
          .findReferencesAsNodes()
          .map((ref) => ref.getFirstAncestor(Node.isExportable))
          .filter((x) => x)
          .filter(Node.isNamed)
          .map((node) => ({
            sourceFilePath: path.relative(process.cwd(), node.getSourceFile().getFilePath()),
            symbolName: node.getName(),
          }))
        : [];

      const exportableSymbol: ExportableSymbol = {
        kind: "directExport",
        name: symbolName,
        sourcePath: source.path,
        structure,
        references,
      };

      if (symbolNameToExport.has(symbolName)) {
        symbolNameToExport.set(
          symbolName,
          combineExportableSymbol(symbolNameToExport.get(symbolName)!, exportableSymbol)
        );
      } else {
        symbolNameToExport.set(symbolName, exportableSymbol);
      }
    }
  }

  let directExports = Array.from(symbolNameToExport.values()).filter(
    (x) => x.kind === "directExport"
  ) as DirectExportableSymbol[];
  const emitExports = Array.from(symbolNameToExport.values()).filter(
    (x) => x.kind === "emit"
  ) as EmittedExportableSymbol[];

  // Inspect references for our direct exports. If anything references an emitted type, then the direct export itself should be emitted.
  // This should be done recursively.
  while (true) {
    const directExportsReferencingEmittedExports = directExports.filter((directExport) =>
      emitExports.some((emitExport) =>
        emitExport.references.find(
          (reference) =>
            reference.symbolName === directExport.name
        )
      )
    );

    if (directExportsReferencingEmittedExports.length === 0) {
      break;
    }

    for (const directExport of directExportsReferencingEmittedExports) {
      // mark as emit
      emitExports.push({ ...directExport, kind: "emit" });
    }

    directExports = directExports.filter(
      (x) => !directExportsReferencingEmittedExports.includes(x)
    );
  }

  // 2. For things which we are now emitting, emit the expected output.
  for (const exp of emitExports) {
    output.addStatements([exp.structure]);
  }

  // 3. For things we can export directly ('directExport', everything at the moment), group by file name and emit a single export statement per file
  const fileToExportSymbols = new Map<string, string[]>();
  for (const exp of directExports) {
    if (exp.kind !== "directExport") continue;

    const list = fileToExportSymbols.get(exp.sourcePath) ?? [];
    fileToExportSymbols.set(exp.sourcePath, [...list, exp.name]);
  }

  for (const [fileName, symbolNames] of fileToExportSymbols) {
    // Path is originally relative to the base dir but we don't want that for the exports file
    const relativePath = path.relative(path.dirname(definition.outputPath), fileName);
    output.addExportDeclaration({
      moduleSpecifier: `./${relativePath.replace(/\.ts$/, esm ? ".js" : "")}`,
      namedExports: symbolNames,
    });
  }

  // Add the disclaimer
  output.insertText(0, EXPORTS_FILE_FRONTMATTER);
  output.fixMissingImports();

  console.log("Emitting", output.getFilePath());
}

export async function makeExports(): Promise<void> {
  const exportsYml = await readExportsYml();
  const project = await resolveProject();
  const tsMorphProject = new Project({
    tsConfigFilePath: path.join(project.path, "tsconfig.json"),
  });
  for (const file of exportsYml.exports) {
    await emitExportsFile(tsMorphProject, exportsYml.esm ?? false, file);
  }

  await tsMorphProject.emit();
  await tsMorphProject.save();
}
